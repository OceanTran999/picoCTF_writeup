![Chal](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/c9c65d7b-4c7f-4b08-937f-f7f70d237c3c)


Check type of vulnerable program file:

![file](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/44cbf983-2229-4e23-bfbb-cf6221851051)


Check file's protection:

![checksec](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/834387f0-ee3e-49d2-8db7-3b6730fd2018)


Here're some functions:

![main](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/9b8117ba-12e6-4038-a2c2-1d79c425fe0b)


![do_stuff](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/9d61f4f1-4752-4b40-8958-e6c10dfaaf6d)


I see there's `atoi()` function and check the man page to see if this function can help to find the vulnerability. Unfortunately, it's just the function that convert from `string` to `int` or `long int`, which means the program is not permitted to input as a character or a string as it will convert to a number. So we **MUST** guess right.

![atoi](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/c04e3df3-2952-4348-80f9-62a233929cb7)


As we can see in `do_stuff()` function, first it will get a random number, then it will take the remainder after `divide to 100`, and finally `plus 1` to get the final number.

![increment_getrandom](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/7ace4280-c6cd-406d-ada1-1508d6ed62c5)


I will write a simple program to check whether the `rand()` function in C will create randomly numbers after running program in different time.

![code_checkrandomp1](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/dde24f98-8f9a-49c9-83e3-4fb88aa3b19f)


![result_randomcodep2](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/25767c2b-6363-418c-b78a-e9288f16ca21)


Yes :) it does not change anything, so what if I write the same as the challenge code?

![code_checkrandomp2](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/45d2cb99-6709-4e3b-a6b6-ae0b1e390e62)


![result_randomcode](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/4b0aae4d-b49a-4d8e-b8d5-83e3ab00eeb5)


Wow ðŸ˜®. The values are not different when running the program in different time, so let testing the program game.

![winner](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/1ee86cac-de60-47f8-bffd-0a31029f962b)


Okay, we did it. Now let's check the `win()` function

![win_func](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/aa3f4187-b44d-4e14-ac59-87762e56681c)


As we can see, there's a buffer overflow vulnerability as the `fgets` function allow to input with 360 bytes, while the size of buffer is only 100. The thing that I focus on most is when debugging the program using `GDB`, I don't see the canary value.

![gdb](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/6ed2cf5b-fb7c-47dd-b2e7-cfe759bd6073)


I will try to make the buffer overflow attack when inputting the name's player, when the result is `segmentation fault`.

![no_canary](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/ae83e7ed-beec-42e0-afdb-a0ab437bd8ca)


![disas_win](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/8ff8dc3d-a6e6-424a-a59a-de6f76244f56)


Ah ha!!! In the `Makefile` file, there's option `-fno-stack-protection` which means the canary will not be used. Therefore the canary in `checksec` we saw is a fake result :(

![Makefile](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/6afabdcc-f8da-4296-8bc6-c6ee77a5c968)


Alright, we know how to attack. Now, as the program does not display the flag or a function that can interact with shell, we need to use ROP to exploit. We will use ROP to call `execve()` function to get the shell server. Here's the table of registers in `x86_64`.

![execve_table](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/33d2dc75-cd05-4a08-b061-e2c4c12ce714)


The address of Gadget we need:

![pop_rax](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/943e9e87-5c6c-49c2-a914-f461d8529b5c)


![pop_rdi](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/c4d76554-59bb-4eb5-8285-ae0d40643694)


![pop_rdx](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/bb9e9dad-51ea-477f-b6a0-13d3579b4666)


![pop_rsi](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/3b793b50-8625-4e71-a6eb-681063f6897d)


![int_0x80](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/cdbb117c-1dee-4c4b-a822-0f9fd77567e1)


I use `vmmap` to check where the address of program that has `WRITE` permission:

![vmmap](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/e51aec88-79d4-405d-a090-e5a4df2a1b45)


First, I will move `/bin/sh` to the value memory of address of `rdi` register, then when call the `execve()` function, it will point to the value of address of `rdi` register which is `/bin/sh`

![reg_addr](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/2533c46a-1ce9-405b-b670-369194465b5f)


![addr_mem](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/807dfea7-4cb5-4efd-bfb1-5d347b8e070a)


![mov_ret](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/597c279b-9b51-4ae1-bb9f-7db84011244e)


When running the program it's not worked, I forgot to add the `syscall` Gadget :") . Finally, we got the flag

![syscall](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/dec04572-b833-4d49-863b-29c8e6f00797)


![flag](https://github.com/OceanTran999/picoCTF_writeup/assets/100577019/e1ed0fe7-9a6d-4297-b52a-c3cc6bb1f007)
